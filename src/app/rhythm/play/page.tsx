"use client";

import { Suspense, useEffect, useRef, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { Container } from "@/components/layout/container";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";

import { loadVocabCsv } from "@/lib/vocab";
import { buildQuizSet, type Quiz } from "@/lib/question-engine";
import { useMetronome } from "@/lib/use-metronome";
import { speak } from "@/lib/tts";
import { sfx } from "@/lib/sfx";
import { startVoice, stopVoice, voiceSupported, warmupMic, getMicPermissionState } from "@/lib/voice";
import { getLatencyOffset, calibrateOnce } from "@/lib/latency";
import { saveSession, type SessionItem, getWrongWeights } from "@/lib/store";

const QUIZ_COUNT = 5;
const DEFAULT_BPM = 90;

type Phase = "ready" | "prompt" | "choices" | "judge" | "interlude";

function RhythmPlayInner() {
  const router = useRouter();
  const sp = useSearchParams();

  const reviewMode = sp.get("mode") === "review";
  const [loading, setLoading] = useState(true);
  const [err, setErr] = useState<string | null>(null);

  const [qs, setQs] = useState<Quiz[]>([]);
  const [idx, setIdx] = useState(0);

  const [phase, setPhase] = useState<Phase>("ready");
  const [selected, setSelected] = useState<number | null>(null);
  const itemsRef = useRef<SessionItem[]>([]);
  const startedAtRef = useRef<number>(Date.now());

  const [correct, setCorrect] = useState(0);
  const [streak, setStreak] = useState(0);
  const [maxStreak, setMaxStreak] = useState(0);
  const justStartedRef = useRef(false);

  const barBeatRef = useRef(0);
  const judgedThisCycleRef = useRef(false);
  const answerCenterAtRef = useRef<number>(0);
  const latencyRef = useRef<number>(0);

  const [micOn, setMicOn] = useState(false);
  const [heardInterim, setHeardInterim] = useState<string>("");
  const [heardFinal, setHeardFinal] = useState<string>("");
  const [noAnswerMsg, setNoAnswerMsg] = useState<string>("");

  const idxRef = useRef(0);
  const phaseRef = useRef<Phase>("ready");
  useEffect(() => { idxRef.current = idx; }, [idx]);
  useEffect(() => { phaseRef.current = phase; }, [phase]);

  const [debugRhythm, setDebugRhythm] = useState(false);
  const [centerAtMs, setCenterAtMs] = useState<number | null>(null);
  const [debugVoice, setDebugVoice] = useState(false);
  const [interimText, setInterimText] = useState<string>("");
  const [voiceErr, setVoiceErr] = useState<string>("");
  const [micPerm, setMicPerm] =
    useState<'granted' | 'denied' | 'prompt' | 'unsupported'>('unsupported');

  // ÂèÇËÄÉË°®Á§∫Áî®
  const [matchInfo, setMatchInfo] = useState<{
    spokenRaw: string;
    spokenNorm: string;
    rule: 'number' | 'keyword' | 'label' | 'none';
    matchedIndex: number | null;
    note?: string;
  } | null>(null);

  // Ë™ûÂΩô„É≠„Éº„ÉâÔºÜÂá∫È°åÊßãÊàê
  useEffect(() => {
    (async () => {
      try {
        setLoading(true);
        const vocab = await loadVocabCsv("/vocab.csv");
        if (!vocab.length) throw new Error("ËæûÊõ∏„ÅåÁ©∫„Åß„Åô");
        const weight = getWrongWeights();
        const quiz = buildQuizSet(vocab, QUIZ_COUNT, weight, { reviewOnly: reviewMode });
        if (!quiz.length) {
          throw new Error(reviewMode ? "Âæ©ÁøíÂØæË±°„Åå„ÅÇ„Çä„Åæ„Åõ„ÇìÔºàË™§Á≠îÂ±•Ê≠¥„ÅåÁ©∫„Åß„ÅôÔºâ" : "ÂïèÈ°å„ÅåÁîüÊàê„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü");
        }
        setQs(quiz);
        setIdx(0);
        setPhase("ready");
        setErr(null);
      } catch (e: any) {
        setErr(e?.message ?? "Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü");
      } finally {
        setLoading(false);
      }
    })();
  }, [reviewMode]);

  const q = qs[idx];
  const progress = qs.length ? (idx / qs.length) * 100 : 0;

  // Âà§ÂÆö
  const judgeNow = (ok: boolean) => {
    if (!q || judgedThisCycleRef.current) return;
    setPhase("judge");
    judgedThisCycleRef.current = true;

    ok ? sfx.ok() : sfx.ng();

    setCorrect((x) => x + (ok ? 1 : 0));
    setStreak((s) => {
      const ns = ok ? s + 1 : 0;
      setMaxStreak((m) => Math.max(m, ns));
      return ns;
    });

    const chosenText = selected != null ? q.choices[selected] : null;
    itemsRef.current.push({
      vocabId: q.id,
      word: q.word,
      correctText: q.choices[q.answer],
      chosenText,
      correct: ok,
    });
  };

  // Êï∞Â≠ó‚Üí„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
  const numWordToIndex = (raw: string): number | null => {
    const t = raw.trim();
    const map: Record<string, number> = {
      "1": 0, "„ÅÑ„Å°": 0, "„Å≤„Å®„Å§": 0, "„ÅÑ„Å°„Å∞„Çì": 0, "„Å†„ÅÑ„ÅÑ„Å°": 0,
      "2": 1, "„Å´": 1, "„Åµ„Åü„Å§": 1, "„Å´„Å∞„Çì": 1, "„Å†„ÅÑ„Å´": 1,
      "3": 2, "„Åï„Çì": 2, "„Åø„Å£„Å§": 2, "„Åï„Çì„Å∞„Çì": 2, "„Å†„ÅÑ„Åï„Çì": 2,
      "4": 3, "„Çà„Çì": 3, "„Åó": 3, "„Çà„Å£„Å§": 3, "„Çà„Çì„Å∞„Çì": 3, "„Å†„ÅÑ„Çà„Çì": 3,
    };
    if (/^[1-4]Áï™?$/.test(t)) return Number(t[0]) - 1;
    return (t in map) ? map[t] : null;
  };

  // „Åã„Å™‰∏ÄËá¥ ‚Üí Êï∞Â≠ó ‚Üí „É©„Éô„É´‰∏ÄËá¥Ôºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
  const tryMatch = (
    spokenRaw: string,
    choices: string[],
    choiceReadings: string[],
  ): { rule: 'number' | 'keyword' | 'label' | 'none'; matchedIndex: number | null; note: string } => {
    // Êï∞Â≠ó
    const num = numWordToIndex(spokenRaw);
    if (num != null && num >= 0 && num < choices.length) {
      return { rule: 'number', matchedIndex: num, note: 'Áï™Âè∑ÊåáÂÆö' };
    }
    // mean_readingÔºà„Åã„Å™Ôºâ
    const kana = spokenRaw.trim();
    const ixKana = choiceReadings.findIndex((r) => (r || '').trim() === kana);
    if (ixKana >= 0) return { rule: 'keyword', matchedIndex: ixKana, note: 'mean_reading‰∏ÄËá¥' };

    // „É©„Éô„É´Êú¨ÊñáÔºàÊéß„Åà„ÇÅ„Å™Ê≠£Ë¶èÂåñÔºâ
    const norm = (s: string) =>
      s.normalize('NFKC').replace(/[\s„ÄÅ„ÄÇ„Éª.,/\\|_*+~^$()[\]{}"'`!?@#:;<>-]/g, "");
    const spokenLbl = norm(spokenRaw);
    const ixLbl = choices.findIndex((c) => norm(c) === spokenLbl);
    if (ixLbl >= 0) return { rule: 'label', matchedIndex: ixLbl, note: 'Ë°®Á§∫„É©„Éô„É´‰∏ÄËá¥' };

    return { rule: 'none', matchedIndex: null, note: '‰∏ç‰∏ÄËá¥' };
  };

  // Èü≥Â£∞ÁµêÊûú
  const onVoice = (spoken: { text: string; normalized: string; confidence: number; at: number }) => {
    if (!q || phaseRef.current !== "choices" || judgedThisCycleRef.current) return;
    if (spoken.confidence < 0.3) return;

    
    const raw = (spoken.text || "").trim();
    const res = tryMatch(raw, q.choices, q.choiceReadings);
    setMatchInfo({
      spokenRaw: raw,
      spokenNorm: spoken.normalized,
      rule: res.rule,
      matchedIndex: res.matchedIndex,
      note: res.note,
    });

    if (res.matchedIndex == null) {
      setNoAnswerMsg("ËÅû„ÅçÂèñ„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶Èü≥Â£∞„ÅßÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
      return;
    }

    setSelected(res.matchedIndex);
    sfx.click();
    const ok = res.matchedIndex === q.answer;
    judgeNow(ok);
  };

  // „É°„Éà„É≠„Éé„Éº„É†
  const { bpm, isRunning, start, stop } = useMetronome(DEFAULT_BPM, () => {
    if (!q) return;
    barBeatRef.current = ((barBeatRef.current % 8) + 1);
    const b = barBeatRef.current;

    if (b === 1 && (phaseRef.current === "ready" || phaseRef.current === "interlude")) {
      setPhase("prompt");
      judgedThisCycleRef.current = false;
      if (justStartedRef.current) { justStartedRef.current = false; }
      speak(q.word, { lang: "ja-JP", rate: 0.95 });
      sfx.click();
    }

    if ((b === 2 || b === 3) && phaseRef.current !== "judge") sfx.click();

    if (b === 4 && phaseRef.current === "prompt") {
      setPhase("choices");
      sfx.click();
      const beatMs = 60000 / bpm;
      answerCenterAtRef.current = performance.now() + beatMs * 0.5;
      setCenterAtMs(Math.round(answerCenterAtRef.current));
      setNoAnswerMsg("");
      setHeardInterim("");
      setHeardFinal("");
    }

    // Ëá™Âãï√ó„ÅØ„Åó„Å™„ÅÑÔºàÂêå‰∏ÄÂïèÈ°åÁ∂ôÁ∂öÔºâ
    if (b === 8 && phaseRef.current === "choices" && !judgedThisCycleRef.current) {
      setNoAnswerMsg("ËÅû„ÅçÂèñ„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶Èü≥Â£∞„ÅßÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
      setHeardInterim("");
      setHeardFinal("");
    }
  });

  // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
  useEffect(() => {
    return () => {
      stop();
      stopVoice();
      try { setMicOn(false); } catch {}
    };
  }, [stop]);

  // „Éá„Éê„ÉÉ„Ç∞„Éï„É©„Ç∞
  useEffect(() => {
    try {
      setDebugRhythm(localStorage.getItem("kogoto:debugRhythm") === "1");
      setDebugVoice(localStorage.getItem("kogoto:debugVoice") === "1");
    } catch {}
  }, []);

  // „Çπ„Çø„Éº„Éà
  const startPlay = async () => {
    if (!q) return;

    // 1) „ÇØ„É™„ÉÉ„ÇØÁõ¥Âæå„Å´Ê®©Èôê„ÉÄ„Ç§„Ç¢„É≠„Ç∞
    let granted = false;
    if (voiceSupported() && !micOn) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach((t) => t.stop());
        granted = true;
        setMicPerm("granted");
        setVoiceErr("");
      } catch {
        setMicPerm("denied");
        setVoiceErr("„Éû„Ç§„ÇØÊ®©Èôê„Åå„Éñ„É≠„ÉÉ„ÇØ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇüîí‚Üí„Çµ„Ç§„Éà„ÅÆË®≠ÂÆö„Åã„Çâ„Äé„Éû„Ç§„ÇØ„ÇíË®±ÂèØ„Äè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
      }
    }

    // 2) Ë™çË≠òÈñãÂßã
    if (granted) {
      const ok = startVoice({
        lang: "ja-JP",
        onResult: (r) => {
          if (idxRef.current !== idx || phaseRef.current !== "choices") return;
          setInterimText("");
          setHeardInterim("");
          setHeardFinal(r.text);
          onVoice({ text: r.text, normalized: r.normalized, confidence: r.confidence, at: r.at });
        },
        onInterim: (t) => {
          if (idxRef.current !== idx || phaseRef.current !== "choices") return;
          setInterimText(t);
          setHeardInterim(t);
        },
        onError: (msg) => setVoiceErr(msg),
      });
      if (ok) setMicOn(true);
    }

    // 3) Êó¢Â≠òÈñãÂßãÂá¶ÁêÜ
    if (!latencyRef.current) latencyRef.current = getLatencyOffset() || (await calibrateOnce(120));
    await start();
    // Ë™≠„Åø‰∏ä„Åí„ÅØ„ÄåÊãç1„Äç„ÅÆ„Çø„Ç§„Éü„É≥„Ç∞„ÅßË°å„ÅÜ„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØ phase „ÇíÂ§â„Åà„Å™„ÅÑ
    justStartedRef.current = true;
    setPhase("ready");
    barBeatRef.current = 0;
  };

  const canAnswer = phase === "choices" && isRunning;

  // Ê¨°„ÅÆÂïèÈ°å„Å∏ÔºàÊâãÂãïÔºâ
  const goNext = () => {
    if (!q) return;
    if (idx + 1 < qs.length) {
      setIdx((i) => i + 1);
      setPhase("interlude");
      barBeatRef.current = 0;
      judgedThisCycleRef.current = false;
      setSelected(null);
      setHeardInterim("");
      setHeardFinal("");
      setNoAnswerMsg("");
      return;
    }
    // ÁµÇ‰∫Ü ‚Üí ‰øùÂ≠òÔºÜÁµêÊûú„Å∏
    const total = qs.length;
    const wrongIds = itemsRef.current.filter((it) => !it.correct).map((it) => it.vocabId);
    stop();
    saveSession({
      id: String(Date.now()),
      startedAt: startedAtRef.current,
      items: itemsRef.current,
      correctRate: total ? correct / total : 0,
      comboMax: maxStreak,
      earnedPoints: correct * 10 + maxStreak * 2,
      wrongIds,
    });
    itemsRef.current = [];
    startedAtRef.current = Date.now();
    const p = new URLSearchParams({
      total: String(total),
      correct: String(correct),
      streak: String(maxStreak),
    });
    router.push(`/rhythm/result?${p.toString()}`);
  };

  return (
    <Container>
      <Card>
        <CardContent className="p-6 md:p-8">
          {loading && <div className="opacity-70">ËæûÊõ∏„ÇíË™≠„ÅøËæº„Çì„Åß„ÅÑ„Åæ„Åô‚Ä¶</div>}
          {err && <div className="text-red-600 font-semibold">Error: {err}</div>}

          {!loading && !err && q && (
            <>
              <div className="flex items-center justify-between mb-4">
                <div className="font-semibold">
                  „É™„Ç∫„É†Â≠¶ÁøíÔºö{idx + 1} / {qs.length}
                </div>
                <div className="text-sm opacity-70 flex items-center gap-3">
                  <span>BPM: {bpm} Ôºè COMBO: {streak}</span>
                  <span className="px-2 py-0.5 rounded border border-[var(--border-strong)] bg-[var(--card)]">
                    „Éû„Ç§„ÇØ: {voiceSupported() ? (micOn ? "ON" : "OFF") : "Êú™ÂØæÂøú"}
                  </span>
                </div>
              </div>
              <Progress value={progress} className="mb-6" />

              <div className="flex gap-2 mb-4">
                {!isRunning ? (
                  <Button onClick={startPlay} disabled={!!err}>
                    {reviewMode ? "Âæ©Áøí„Çπ„Çø„Éº„Éà" : "„Çπ„Çø„Éº„Éà"}
                  </Button>
                ) : (
                  <Button
                    variant="accent"
                    onClick={() => {
                      stop();
                      stopVoice();
                      setMicOn(false);
                    }}
                  >
                    „Çπ„Éà„ÉÉ„Éó
                  </Button>
                )}
              </div>

              <div className="text-2xl font-extrabold mb-2">„Äå{q.word}„Äç„ÅÆÁèæ‰ª£Ë™û„ÅØÔºü</div>
              <div className="text-sm opacity-70 mb-4">
                {phase === "prompt" && "ÊèêÁ§∫‰∏≠‚Ä¶ÔºàÊãç1Ôºâ"}
                {phase === "choices" && "ÈÅ∏ÊäûËÇ¢„Çí„Çø„ÉÉ„ÉóÔºÅor Â£∞„Åß„Äé1/2/3/4„Äè„ÇÑ „Åã„Å™Ë™≠„ÅøÔºÅ"}
                {phase === "judge" && "Âà§ÂÆö‰∏≠ÔºÅ"}
                {phase === "ready" && (reviewMode ? "Âæ©ÁøíÂØæË±°„Åã„ÇâÂá∫È°å„Åó„Åæ„Åô" : "„Çπ„Çø„Éº„Éà„ÇíÊäº„Åó„Å¶„Å≠")}
              </div>

              {/* üé§ËÅû„ÅçÂèñ„Çä„ÅÆÂèØË¶ñÂåñ */}
              <div className="text-xs mb-3 inline-flex items-center gap-2 px-2 py-1 rounded border border-[var(--border-strong)] bg-[var(--card)]" aria-live="polite">
                <span>üé§</span>
                {micPerm === "denied" ? (
                  <span className="opacity-70">„Éû„Ç§„ÇØ„ÅØ„Éñ„É≠„ÉÉ„ÇØ‰∏≠Ôºàüîí‚Üí„Çµ„Ç§„ÉàË®≠ÂÆö„ÅßË®±ÂèØÔºâ</span>
                ) : heardInterim ? (
                  <span>ËÅû„ÅçÂèñ„Çä‰∏≠Ôºö<b>{heardInterim}</b></span>
                ) : heardFinal ? (
                  <span>Á¢∫ÂÆöÔºö<b>{heardFinal}</b></span>
                ) : (
                  <span className="opacity-70">ÂæÖÊ©ü‰∏≠‚Ä¶ {noAnswerMsg && <em>{noAnswerMsg}</em>}</span>
                )}
              </div>

              {debugVoice && (
                <div className="text-xs mb-3 px-2 py-1 rounded border border-[var(--border-strong)] bg-[var(--card)]">
                  <div>interim: <span className="opacity-70">{interimText || "Ôºà„Å™„ÅóÔºâ"}</span></div>
                  <div>error: <span className="opacity-70">{voiceErr || "Ôºà„Å™„ÅóÔºâ"}</span></div>
                  <div>permission: <span className="opacity-70">{micPerm}</span></div>
                  {matchInfo && (
                    <div className="mt-2">
                      <div>rule: <b>{matchInfo.rule}</b> / note: {matchInfo.note || "‚Äî"}</div>
                      <div>spoken(norm): <code>{matchInfo.spokenNorm}</code></div>
                      <div>matchedIndex: {matchInfo.matchedIndex ?? "‚Äî"}</div>
                    </div>
                  )}
                  <button
                    className="mt-1 px-2 py-0.5 rounded border"
                    onClick={async () => {
                      const ok = await warmupMic();
                      const st = await getMicPermissionState();
                      setMicPerm(st);
                      if (!ok && (st === "denied" || st === "prompt")) {
                        setVoiceErr("„Éû„Ç§„ÇØË®±ÂèØ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºàüîí‚Üí„Çµ„Ç§„ÉàË®≠ÂÆö‚Üí„Éû„Ç§„ÇØÔºâ„ÄÇ");
                      } else {
                        setVoiceErr("");
                      }
                    }}
                  >
                    Ê®©Èôê„ÇíÂÜç„ÉÅ„Çß„ÉÉ„ÇØ
                  </button>
                  {micPerm === "denied" && (
                    <div className="mt-1 opacity-70">
                      „Éí„É≥„Éà: <b>http://127.0.0.1:3000</b> „ÇíÂà•„Ç™„É™„Ç∏„É≥„Å®„Åó„Å¶Èñã„Åè„Å®ÂÜçÁ¢∫Ë™ç„Åß„Åç„Åæ„Åô„ÄÇ
                    </div>
                  )}
                </div>
              )}

              {debugRhythm && (
                <div className="text-xs mb-3 px-2 py-1 inline-flex gap-3 rounded border border-[var(--border-strong)] bg-[var(--card)]">
                  <span>Âà§ÂÆö„Çª„É≥„Çø„Éº(ms): {centerAtMs ?? "‚Äî"}</span>
                </div>
              )}

              {/* ÈÅ∏ÊäûËÇ¢ÔºöÈü≥Â£∞„Åß„Éí„ÉÉ„Éà„Åó„Åü„Çâ selected „ÇíÂèçÊò†„Åó„Å¶ÂÖâ„Çã */}
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                {q.choices.map((txt, idxChoice) => (
                  <Button
                    key={idxChoice}
                    variant="surface"
                    size="lg"
                    disabled={!canAnswer}
                    onClick={() => {
                      if (!canAnswer) return;
                      setSelected(idxChoice);
                      sfx.click();
                      judgeNow(idxChoice === q.answer);
                    }}
                    className={
                      phase === "judge"
                        ? idxChoice === q.answer
                          ? "bg-green-300"
                          : selected === idxChoice
                            ? "bg-red-300"
                            : "opacity-70"
                        : selected === idxChoice
                          ? "outline outline-4"
                          : ""
                    }
                  >
                    {txt}
                  </Button>
                ))}
              </div>

              {/* Âà§ÂÆöÂæå„ÅØÊâãÂãï„ÅßÊ¨°„Å∏ */}
              {phase === "judge" && (
                <div className="mt-4">
                  <Button variant="primary" size="lg" onClick={goNext}>
                    Ê¨°„ÅÆÂïèÈ°å„Å∏
                  </Button>
                </div>
              )}
            </>
          )}
        </CardContent>
      </Card>
    </Container>
  );
}

export default function Page() {
  return (
    <Suspense fallback={<div className="p-6 opacity-70">„É≠„Éº„Éâ‰∏≠‚Ä¶</div>}>
      <RhythmPlayInner />
    </Suspense>
  );
}
